<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Handling Distributed Transactions: A Deep Dive into the Saga Pattern | ùê∑ùëíùë£‚Ñùùë•.ùëñùëú</title>
<meta name=keywords content="microservice,distributed system,messaging,saga,EDA,Choreography,Orchestration,distributed transaction,saga choreography,saga orchestration"><meta name=description content="Explore the Saga Pattern for managing distributed transactions in microservices. Learn how it ensures data consistency through choreography and orchestration, making complex systems resilient and scalable."><meta name=author content="Saddam H"><link rel=canonical href=https://devrx.io/posts/distributed-transaction-with-saga-pattern/><meta name=google-site-verification content="tz-hi3YdV_-s4rWQsQr1-YeYBoJL-ZNMIr6Kx4d-rVo"><link crossorigin=anonymous href=/assets/css/stylesheet.bf1de4f9ee89973f777a00ea792a11a155aee51e0ec21e4fbccf0ddd804b2f47.css integrity="sha256-vx3k+e6Jlz93egDqeSoRoVWu5R4Owh5PvM8N3YBLL0c=" rel="preload stylesheet" as=style><link rel=icon href=https://devrx.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://devrx.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://devrx.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://devrx.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://devrx.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://devrx.io/posts/distributed-transaction-with-saga-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F4DLT0VTX0"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F4DLT0VTX0")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2225244453485950" crossorigin=anonymous></script><meta name=google-adsense-account content="ca-pub-2225244453485950"><meta property="og:url" content="https://devrx.io/posts/distributed-transaction-with-saga-pattern/"><meta property="og:site_name" content="ùê∑ùëíùë£‚Ñùùë•.ùëñùëú"><meta property="og:title" content="Handling Distributed Transactions: A Deep Dive into the Saga Pattern"><meta property="og:description" content="Explore the Saga Pattern for managing distributed transactions in microservices. Learn how it ensures data consistency through choreography and orchestration, making complex systems resilient and scalable."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-18T00:00:00+00:00"><meta property="article:tag" content="Microservice"><meta property="article:tag" content="Distributed System"><meta property="article:tag" content="Messaging"><meta property="article:tag" content="Saga"><meta property="article:tag" content="EDA"><meta property="article:tag" content="Choreography"><meta property="og:image" content="https://devrx.io/media/posts/distributed-transaction-with-saga-pattern/cover.svg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://devrx.io/media/posts/distributed-transaction-with-saga-pattern/cover.svg"><meta name=twitter:title content="Handling Distributed Transactions: A Deep Dive into the Saga Pattern"><meta name=twitter:description content="Explore the Saga Pattern for managing distributed transactions in microservices. Learn how it ensures data consistency through choreography and orchestration, making complex systems resilient and scalable."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://devrx.io/posts/"},{"@type":"ListItem","position":2,"name":"Handling Distributed Transactions: A Deep Dive into the Saga Pattern","item":"https://devrx.io/posts/distributed-transaction-with-saga-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Handling Distributed Transactions: A Deep Dive into the Saga Pattern","name":"Handling Distributed Transactions: A Deep Dive into the Saga Pattern","description":"Explore the Saga Pattern for managing distributed transactions in microservices. Learn how it ensures data consistency through choreography and orchestration, making complex systems resilient and scalable.","keywords":["microservice","distributed system","messaging","saga","EDA","Choreography","Orchestration","distributed transaction","saga choreography","saga orchestration"],"articleBody":"In today‚Äôs world, scalability is a common challenge that most of us face when developing applications. To scale out and build easily manageable services, we often break down a system‚Äôs responsibilities into multiple microservices. In a microservices architecture, each service manages its own database, and the type of database can differ between services. This diversity complicates implementing a two-phase commit, and in many cases, services don‚Äôt always require strong consistency.\nHTTP Call to Update Inventory (Service Unavailable)\nLet‚Äôs explore this issue using an example of an e-commerce platform, where we might have an order service and an inventory service. When a user places an order, the order service creates an entry in its database and needs to update the product inventory once the payment is successfully processed.\nSince these are two separate services, potentially managed by different teams, one might use a relational database like PostgreSQL, while the other could rely on a NoSQL database like MongoDB.\nWhen placing an order, we know the operation must be handled as a transaction. The order cannot be placed without updating the inventory, and the inventory cannot be updated without placing the order.\nBefore going further, we need to understand what is transaction? Well, transaction is a sequence of operations performed as a single logical unit of work, ensuring atomicity, consistency, isolation and durability, either complete success or full rollback. These properties are available in relational databases like MySQL and PostgreSQL to maintain data consistency. ACID supported relational databases generally uses 2PC (two phase commit) to ensure strong consistency. However, in distributed systems this is more complex and harder to achieve.\nTo manage transactions in distributed systems, we can utilize the Saga pattern. In our previous article, we explored how distributed services interact through Choreography and Orchestration , as well as how to ensure data integrity and consistency using the Outbox pattern.\nThe Saga pattern can be implemented in two ways: one approach involves a central orchestrator managing the transaction lifecycle, while the other relies on choreography. Let‚Äôs delve into both approaches of the Saga pattern using real-life examples.\nSaga Orchestration Saga orchestration is a pattern used to manage transactions that span multiple microservices. Instead of relying on traditional distributed transactions (which are difficult to implement in microservices due to their independence), a saga splits the transaction into smaller, local transactions. Each service performs its task and then informs a central Orchestrator, which coordinates the workflow.\nIf one service fails, the orchestrator triggers compensating actions to undo the work of previous services, ensuring consistency across the system. This rollback mechanism is essential in ensuring the system does not leave the platform in an inconsistent state when something goes wrong.\nHandling Distributed Transactions in the Event of a Local Transaction Failure\nIn an e-commerce system, the process to place an order spans multiple services. The Order Service handles the order placement, followed by the Payment Service for processing payment. Once the payment is successful, the Inventory Service updates stock, and finally, the Notification Service sends an email to inform the user about the order status.\nThese services need to interact in a sequence to complete an order, and if something fails (for example: Inventory service failed), the system needs to gracefully roll back the transaction. Here‚Äôs how saga orchestration ensures smooth operation.\nStep-by-Step Workflow:\nOrder Creation When a customer places an order, the first step in the workflow is creating the order in the system. The Order Service receives the request, creates a new order record, and marks the order as ‚ÄúPENDING‚Äù until the payment is processed.\nOnce the order is created, the Orchestrator is notified and takes control of the workflow. It then instructs the next microservice, the Payment Service, to process the payment for the order.\nPayment Processing The Payment Service is responsible for charging the customer‚Äôs payment method. This could involve processing a credit card, using a third-party payment gateway, or another form of transaction.\nIf the payment is successful, the Payment Service informs the Orchestrator, and the transaction continues to the next step. However, if the payment fails‚Äîperhaps due to insufficient funds or a payment gateway error‚Äîthe orchestrator is immediately notified, and the saga begins its compensation process.\nUpdate inventory Once the payment is successful, the orchestrator will update the inventory and reduce the product stock quantity.\nSending Notifications Assuming the previous steps succeeded, the next step is to notify the customer that their order has been successfully placed. The Orchestrator instructs the Notification Service to send an order confirmation email or SMS to the customer.\nThis step completes the transaction. Once the notification is sent, the orchestrator updates the status of the order from ‚ÄúPENDING‚Äù to ‚ÄúCOMPLETED,‚Äù and the saga ends successfully. Note: we can update the state to ‚ÄòCOMPLETED‚Äô based on the previous step as notification can be optional in terms of this transaction.\nHandling Failures and Rollbacks Failures in any distributed system are inevitable. With the saga orchestration pattern, handling these failures becomes much more manageable. Let‚Äôs explore what happens when things don‚Äôt go as planned.\nPayment Failure: If the Payment Service fails to process the payment (due to a technical issue or insufficient funds), the orchestrator will initiate the compensation process. This means the Order Service will be asked to cancel the order, update its status to ‚ÄúCANCELED,‚Äù this leads to trigger compensationary transaction C2-\u003eC1.\nThe customer is not charged, and no notification is sent since the order did not go through. The orchestrator logs the failure, ensuring that the platform is aware of the unsuccessful transaction.\nInventory Failure: In the event that the Inventory Service fails to reduce the stock, it triggers a compensation process (C3) that cascades through the transaction, leading to C2 (refund payment) and C1 (cancel order). However, one crucial point to keep in mind is that each service must implement a retry mechanism. This ensures that temporary issues, such as network glitches or momentary downtime, do not result in immediate failure. By retrying, services can attempt to complete their tasks before reporting a failure, minimizing unnecessary rollbacks and ensuring smoother transaction flow.\nNotification Failure: If the Notification Service fails (e.g., due to an issue with the email provider), the orchestrator might not need to roll back the entire transaction. Instead, it can log the failure and notify the system administrator that the customer wasn‚Äôt informed of the order. This is a non-critical error that can be handled separately from the core transaction.\nCan we effectively manage these states and their transitions based on different inputs? Yes, By modeling the process using a Finite State Machine (FSM). FSM allows us to define each state‚Äîsuch as order placement, payment processing, inventory update, and notification‚Äîand map the transitions between them. These transitions are triggered by inputs like Success or Failure at each step. For example, if payment is successful, the FSM moves to the inventory update step; if a failure occurs, it triggers a transition to the appropriate compensation actions. This structured approach helps manage complex workflows efficiently.\nCurrent State Input/Condition Next State Action Order Created (T1) Success Payment Processing (T2) Proceed to payment processing Order Created (T1) Failure Compensation (C1) Cancel the order (C1) Payment Processing (T2) Success Inventory Update (T3) Proceed to inventory update Payment Processing (T2) Failure Compensation (C2, C1) Refund payment (C2) and cancel the order (C1) Inventory Update (T3) Success Completion Complete the order Inventory Update (T3) Failure Compensation (C3, C2, C1) Restore inventory (C3), refund payment (C2), cancel the order (C1) Saga Choreography In the Saga choreography pattern, there is no central orchestrator or coordinator to control the flow of transactions. Instead, services communicate through a message queue or an event bus. Each service listens for specific events or topics and reacts accordingly. Once a service completes its task, it publishes an event or command to signal the next service to continue the process.\nThis decentralized approach allows each service to handle its own part of the transaction independently. For instance, after the Order Service creates an order, it publishes an event. The Payment Service listens for that event, processes the payment, and then publishes another event for the Inventory Service to update stock. The flow continues in this manner, with each service both reacting to and publishing events to move the transaction forward.\nHandling Distributed Transactions through Decentralized Event-Driven Choreography\nLet‚Äôs break down the step-by-step flow of choreography using the Order, Payment, and Inventory services. Each service communicates through events without a central orchestrator, making this an event-driven transaction management system.\nStep-by-Step Workflow:\nOrder Creation Customer places an order and the Order Service processes the order and creates an entry for it. Once the order is successfully created, the service publishes an event called ORDER_CREATED to notify other services.\nPayment Processing The Payment Service listens for the ORDER_CREATED event. Upon receiving it, the Payment Service initiates the payment process (e.g., charging the customer‚Äôs credit card). If the payment is successful, the Payment Service publishes a PAYMENT_COMPLETED event, otherwise the service publishes a PAYMENT_FAILED event, which can trigger a rollback (e.g., cancel the order).\nInventory Update The Inventory Service listens for the PAYMENT_COMPLETED event. When it receives this event, it reduces the stock of the items in the order. If the stock is successfully updated, the Inventory Service publishes an STOCK_UPDATED event to continue the transaction flow. If the stock update fails (e.g., insufficient stock), it publishes a STOCK_UPDATE_FAILED event. This event can trigger compensating actions like issuing a refund and canceling the order.\nSening Notifications The Notification Service listens for the STOCK_UPDATED event. When it receives the event, it sends a confirmation email to the customer, notifying them that their order is complete and ready for shipment. If there were earlier failures (e.g., payment or inventory update failures), the Notification Service can also listen to failure events like PAYMENT_FAILED, STOCK_UPDATE_FAILED or only ORDER_FAILED, notifying the customer about the failure and status of their order.\nHandling Failures and Rollbacks If a failure occurs at any step, such as payment failure or inventory update failure, compensating transactions are triggered via published failure events:\nIf the Payment Service fails to process the payment, it publishes a PAYMENT_FAILED event. The Order Service listens to this event and cancels the order. If the Inventory Service cannot update the stock, it publishes an STOCK_UPDATE_FAILED event, which triggers a refund in the Payment Service and order cancellation in the Order Service.\nTrade-offs Between Saga Orchestration and Choreography When designing distributed systems, choosing between saga orchestration and saga choreography depends on various factors such as complexity, performance, and the flexibility of your architecture.\nOrchestration offers centralized control, making it easier to manage complex workflows, but this can lead to tighter coupling and potential bottlenecks.\nChoreography promotes loose coupling and flexibility, which allows for better scalability and resilience but increases the complexity of managing distributed events and tracking the workflow. Your decision should be based on the specific requirements of your system, including how critical centralized control, flexibility, and scalability are to your application‚Äôs success.\nFor deeper understanding of the interaction mechanisms in distributed systems, please go through my previous article on choreography and orchestration\n","wordCount":"1849","inLanguage":"en","image":"https://devrx.io/media/posts/distributed-transaction-with-saga-pattern/cover.svg","datePublished":"2024-10-18T00:00:00Z","dateModified":"2024-10-18T00:00:00Z","author":{"@type":"Person","name":"Saddam H"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://devrx.io/posts/distributed-transaction-with-saga-pattern/"},"publisher":{"@type":"Organization","name":"ùê∑ùëíùë£‚Ñùùë•.ùëñùëú","logo":{"@type":"ImageObject","url":"https://devrx.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://devrx.io/ accesskey=h title="ùê∑ùëíùë£‚Ñùùë•.ùëñùëú (Alt + H)">ùê∑ùëíùë£‚Ñùùë•.ùëñùëú</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://devrx.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://devrx.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://devrx.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://devrx.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Handling Distributed Transactions: A Deep Dive into the Saga Pattern</h1><div class=post-description>Explore the Saga Pattern for managing distributed transactions in microservices. Learn how it ensures data consistency through choreography and orchestration, making complex systems resilient and scalable.</div><div class=post-meta><span title='2024-10-18 00:00:00 +0000 UTC'>October 18, 2024</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;Saddam H</div></header><figure class=entry-cover><img loading=eager src=https://devrx.io/media/posts/distributed-transaction-with-saga-pattern/cover.svg alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#saga-orchestration aria-label="Saga Orchestration">Saga Orchestration</a><ul><li><a href=#handling-failures-and-rollbacks aria-label="Handling Failures and Rollbacks">Handling Failures and Rollbacks</a></li></ul></li><li><a href=#saga-choreography aria-label="Saga Choreography">Saga Choreography</a><ul><li><a href=#handling-failures-and-rollbacks-1 aria-label="Handling Failures and Rollbacks">Handling Failures and Rollbacks</a></li></ul></li><li><a href=#trade-offs-between-saga-orchestration-and-choreography aria-label="Trade-offs Between Saga Orchestration and Choreography">Trade-offs Between Saga Orchestration and Choreography</a></li></ul></div></details></div><div class=post-content><p>In today‚Äôs world, scalability is a common challenge that most of us face when developing applications. To scale out and build easily manageable services, we often break down a system&rsquo;s responsibilities into multiple microservices. In a microservices architecture, each service manages its own database, and the type of database can differ between services. This diversity complicates implementing a two-phase commit, and in many cases, services don‚Äôt always require strong consistency.</p><figure><img loading=lazy src=/media/posts/distributed-transaction-with-saga-pattern/distributed-transaction-without-saga.svg alt=distributed-transaction-without-saga><figcaption><p>HTTP Call to Update Inventory (Service Unavailable)</p></figcaption></figure><p>Let‚Äôs explore this issue using an example of an e-commerce platform, where we might have an order service and an inventory service. When a user places an order, the order service creates an entry in its database and needs to update the product inventory once the payment is successfully processed.</p><p>Since these are two separate services, potentially managed by different teams, one might use a relational database like PostgreSQL, while the other could rely on a NoSQL database like MongoDB.</p><p>When placing an order, we know the operation must be handled as a transaction. The order cannot be placed without updating the inventory, and the inventory cannot be updated without placing the order.</p><p>Before going further, we need to understand what is transaction? Well, transaction is a sequence of operations performed as a single logical unit of work, ensuring atomicity, consistency, isolation and durability, either complete success or full rollback. These properties are available in relational databases like MySQL and PostgreSQL to maintain data consistency. ACID supported relational databases generally uses 2PC (two phase commit) to ensure strong consistency. However, in distributed systems this is more complex and harder to achieve.</p><p>To manage transactions in distributed systems, we can utilize the Saga pattern. In our previous article, we explored how distributed services interact through <a href=https://devrx.io/posts/mastering-microservices-battle-between-choreography-and-orchestration/ title="Mastering Microservices: The Battle Between Choreography & Orchestration">Choreography and Orchestration</a> , as well as how to ensure data integrity and consistency using the <a href=https://devrx.io/posts/mastering-microservics-ensuring-data-consistency-with-the-outbox-pattern/ title="Mastering Microservices: Ensuring Data Consistency with the Outbox Pattern">Outbox pattern.</a></p><p>The Saga pattern can be implemented in two ways: one approach involves a central orchestrator managing the transaction lifecycle, while the other relies on choreography. Let‚Äôs delve into both approaches of the Saga pattern using real-life examples.</p><h2 id=saga-orchestration>Saga Orchestration<a hidden class=anchor aria-hidden=true href=#saga-orchestration>#</a></h2><p>Saga orchestration is a pattern used to manage transactions that span multiple microservices. Instead of relying on traditional distributed transactions (which are difficult to implement in microservices due to their independence), a saga splits the transaction into smaller, local transactions. Each service performs its task and then informs a central Orchestrator, which coordinates the workflow.</p><p>If one service fails, the orchestrator triggers compensating actions to undo the work of previous services, ensuring consistency across the system. This rollback mechanism is essential in ensuring the system does not leave the platform in an inconsistent state when something goes wrong.</p><figure><img loading=lazy src=/media/posts/distributed-transaction-with-saga-pattern/distributed-transaction-with-saga-orchestration.svg alt=distributed-transaction-with-saga-orchestration><figcaption><p>Handling Distributed Transactions in the Event of a Local Transaction Failure</p></figcaption></figure><p>In an e-commerce system, the process to place an order spans multiple services. The Order Service handles the order placement, followed by the Payment Service for processing payment. Once the payment is successful, the Inventory Service updates stock, and finally, the Notification Service sends an email to inform the user about the order status.</p><p>These services need to interact in a sequence to complete an order, and if something fails (for example: Inventory service failed), the system needs to gracefully roll back the transaction. Here‚Äôs how saga orchestration ensures smooth operation.</p><p><strong>Step-by-Step Workflow:</strong></p><ol><li><strong>Order Creation</strong></li></ol><p>When a customer places an order, the first step in the workflow is creating the order in the system. The Order Service receives the request, creates a new order record, and marks the order as &ldquo;PENDING&rdquo; until the payment is processed.</p><p>Once the order is created, the Orchestrator is notified and takes control of the workflow. It then instructs the next microservice, the Payment Service, to process the payment for the order.</p><ol start=2><li><strong>Payment Processing</strong></li></ol><p>The Payment Service is responsible for charging the customer‚Äôs payment method. This could involve processing a credit card, using a third-party payment gateway, or another form of transaction.</p><p>If the payment is successful, the Payment Service informs the Orchestrator, and the transaction continues to the next step. However, if the payment fails‚Äîperhaps due to insufficient funds or a payment gateway error‚Äîthe orchestrator is immediately notified, and the saga begins its compensation process.</p><ol start=3><li><strong>Update inventory</strong></li></ol><p>Once the payment is successful, the orchestrator will update the inventory and reduce the product stock quantity.</p><ol start=4><li><strong>Sending Notifications</strong></li></ol><p>Assuming the previous steps succeeded, the next step is to notify the customer that their order has been successfully placed. The Orchestrator instructs the Notification Service to send an order confirmation email or SMS to the customer.</p><p>This step completes the transaction. Once the notification is sent, the orchestrator updates the status of the order from &ldquo;PENDING&rdquo; to &ldquo;COMPLETED,&rdquo; and the saga ends successfully. Note: we can update the state to &lsquo;COMPLETED&rsquo; based on the previous step as notification can be optional in terms of this transaction.</p><h3 id=handling-failures-and-rollbacks>Handling Failures and Rollbacks<a hidden class=anchor aria-hidden=true href=#handling-failures-and-rollbacks>#</a></h3><p>Failures in any distributed system are inevitable. With the saga orchestration pattern, handling these failures becomes much more manageable. Let‚Äôs explore what happens when things don‚Äôt go as planned.</p><p><em><strong>Payment Failure:</strong></em> If the Payment Service fails to process the payment (due to a technical issue or insufficient funds), the orchestrator will initiate the compensation process. This means the Order Service will be asked to cancel the order, update its status to &ldquo;CANCELED,&rdquo; this leads to trigger compensationary transaction <code>C2->C1</code>.</p><p>The customer is not charged, and no notification is sent since the order did not go through. The orchestrator logs the failure, ensuring that the platform is aware of the unsuccessful transaction.</p><p><em><strong>Inventory Failure:</strong></em> In the event that the Inventory Service fails to reduce the stock, it triggers a compensation process (C3) that cascades through the transaction, leading to C2 (refund payment) and C1 (cancel order). However, one crucial point to keep in mind is that each service must implement a retry mechanism. This ensures that temporary issues, such as network glitches or momentary downtime, do not result in immediate failure. By retrying, services can attempt to complete their tasks before reporting a failure, minimizing unnecessary rollbacks and ensuring smoother transaction flow.</p><p><em><strong>Notification Failure:</strong></em> If the Notification Service fails (e.g., due to an issue with the email provider), the orchestrator might not need to roll back the entire transaction. Instead, it can log the failure and notify the system administrator that the customer wasn‚Äôt informed of the order. This is a non-critical error that can be handled separately from the core transaction.</p><p><details><summary markdown=span>Can we effectively manage these <code>states</code> and their <code>transitions</code> based on different inputs? Yes, By modeling the process using a <a href=https://en.wikipedia.org/wiki/Finite-state_machine>Finite State Machine (FSM)</a>.</summary><p>FSM allows us to define each state‚Äîsuch as order placement, payment processing, inventory update, and notification‚Äîand map the transitions between them. These transitions are triggered by inputs like Success or Failure at each step. For example, if payment is successful, the FSM moves to the inventory update step; if a failure occurs, it triggers a transition to the appropriate compensation actions. This structured approach helps manage complex workflows efficiently.</p><table><thead><tr><th style=text-align:left><strong>Current State</strong></th><th style=text-align:left><strong>Input/Condition</strong></th><th style=text-align:left><strong>Next State</strong></th><th style=text-align:left><strong>Action</strong></th></tr></thead><tbody><tr><td style=text-align:left><code>Order Created (T1)</code></td><td style=text-align:left>Success</td><td style=text-align:left><code>Payment Processing (T2)</code></td><td style=text-align:left>Proceed to payment processing</td></tr><tr><td style=text-align:left><code>Order Created (T1)</code></td><td style=text-align:left>Failure</td><td style=text-align:left><code>Compensation (C1)</code></td><td style=text-align:left>Cancel the order (C1)</td></tr><tr><td style=text-align:left><code>Payment Processing (T2)</code></td><td style=text-align:left>Success</td><td style=text-align:left><code>Inventory Update (T3)</code></td><td style=text-align:left>Proceed to inventory update</td></tr><tr><td style=text-align:left><code>Payment Processing (T2)</code></td><td style=text-align:left>Failure</td><td style=text-align:left><code>Compensation (C2, C1)</code></td><td style=text-align:left>Refund payment (C2) and cancel the order (C1)</td></tr><tr><td style=text-align:left><code>Inventory Update (T3)</code></td><td style=text-align:left>Success</td><td style=text-align:left><code>Completion</code></td><td style=text-align:left>Complete the order</td></tr><tr><td style=text-align:left><code>Inventory Update (T3)</code></td><td style=text-align:left>Failure</td><td style=text-align:left><code>Compensation (C3, C2, C1)</code></td><td style=text-align:left>Restore inventory (C3), refund payment (C2), cancel the order (C1)</td></tr></tbody></table></details></p><h2 id=saga-choreography>Saga Choreography<a hidden class=anchor aria-hidden=true href=#saga-choreography>#</a></h2><p>In the Saga choreography pattern, there is no central orchestrator or coordinator to control the flow of transactions. Instead, services communicate through a message queue or an event bus. Each service listens for specific events or topics and reacts accordingly. Once a service completes its task, it publishes an event or command to signal the next service to continue the process.</p><p>This decentralized approach allows each service to handle its own part of the transaction independently. For instance, after the Order Service creates an order, it publishes an event. The Payment Service listens for that event, processes the payment, and then publishes another event for the Inventory Service to update stock. The flow continues in this manner, with each service both reacting to and publishing events to move the transaction forward.</p><figure><img loading=lazy src=/media/posts/distributed-transaction-with-saga-pattern/distributed-transaction-with-saga-choreography.svg alt=distributed-transaction-with-saga-choreography><figcaption><p>Handling Distributed Transactions through Decentralized Event-Driven Choreography</p></figcaption></figure><p>Let‚Äôs break down the step-by-step flow of choreography using the Order, Payment, and Inventory services. Each service communicates through events without a central orchestrator, making this an event-driven transaction management system.</p><p><strong>Step-by-Step Workflow:</strong></p><ol><li><strong>Order Creation</strong></li></ol><p>Customer places an order and the Order Service processes the order and creates an entry for it. Once the order is successfully created, the service publishes an event called <code>ORDER_CREATED</code> to notify other services.</p><ol start=2><li><strong>Payment Processing</strong></li></ol><p>The Payment Service listens for the <code>ORDER_CREATED</code> event. Upon receiving it, the Payment Service initiates the payment process (e.g., charging the customer‚Äôs credit card). If the payment is successful, the Payment Service publishes a <code>PAYMENT_COMPLETED</code> event, otherwise the service publishes a <code>PAYMENT_FAILED</code> event, which can trigger a rollback (e.g., cancel the order).</p><ol start=3><li><strong>Inventory Update</strong></li></ol><p>The Inventory Service listens for the <code>PAYMENT_COMPLETED</code> event. When it receives this event, it reduces the stock of the items in the order.
If the stock is successfully updated, the Inventory Service publishes an <code>STOCK_UPDATED</code> event to continue the transaction flow. If the stock update fails (e.g., insufficient stock), it publishes a <code>STOCK_UPDATE_FAILED</code> event. This event can trigger compensating actions like issuing a refund and canceling the order.</p><ol start=4><li><strong>Sening Notifications</strong></li></ol><p>The Notification Service listens for the <code>STOCK_UPDATED</code> event. When it receives the event, it sends a confirmation email to the customer, notifying them that their order is complete and ready for shipment.
If there were earlier failures (e.g., payment or inventory update failures), the Notification Service can also listen to failure events like <code>PAYMENT_FAILED</code>, <code>STOCK_UPDATE_FAILED</code> or only <code>ORDER_FAILED</code>, notifying the customer about the failure and status of their order.</p><h3 id=handling-failures-and-rollbacks-1>Handling Failures and Rollbacks<a hidden class=anchor aria-hidden=true href=#handling-failures-and-rollbacks-1>#</a></h3><p>If a failure occurs at any step, such as payment failure or inventory update failure, compensating transactions are triggered via published failure events:</p><p>If the Payment Service fails to process the payment, it publishes a <code>PAYMENT_FAILED</code> event. The Order Service listens to this event and cancels the order.
If the Inventory Service cannot update the stock, it publishes an <code>STOCK_UPDATE_FAILED</code> event, which triggers a refund in the Payment Service and order cancellation in the Order Service.</p><h2 id=trade-offs-between-saga-orchestration-and-choreography>Trade-offs Between Saga Orchestration and Choreography<a hidden class=anchor aria-hidden=true href=#trade-offs-between-saga-orchestration-and-choreography>#</a></h2><p>When designing distributed systems, choosing between saga orchestration and saga choreography depends on various factors such as complexity, performance, and the flexibility of your architecture.</p><p>Orchestration offers centralized control, making it easier to manage complex workflows, but this can lead to tighter coupling and potential
bottlenecks.</p><p>Choreography promotes loose coupling and flexibility, which allows for better scalability and resilience but increases the complexity of managing distributed events and tracking the workflow.
Your decision should be based on the specific requirements of your system, including how critical centralized control, flexibility, and scalability are to your application‚Äôs success.</p><p>For deeper understanding of the interaction mechanisms in distributed systems, please go through my previous article on <a href=https://devrx.io/posts/mastering-microservices-battle-between-choreography-and-orchestration/ title="Mastering Microservices: The Battle Between Choreography & Orchestration">choreography and orchestration</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://devrx.io/tags/microservice/>Microservice</a></li><li><a href=https://devrx.io/tags/distributed-system/>Distributed System</a></li><li><a href=https://devrx.io/tags/messaging/>Messaging</a></li><li><a href=https://devrx.io/tags/saga/>Saga</a></li><li><a href=https://devrx.io/tags/eda/>EDA</a></li><li><a href=https://devrx.io/tags/choreography/>Choreography</a></li><li><a href=https://devrx.io/tags/orchestration/>Orchestration</a></li><li><a href=https://devrx.io/tags/distributed-transaction/>Distributed Transaction</a></li><li><a href=https://devrx.io/tags/saga-choreography/>Saga Choreography</a></li><li><a href=https://devrx.io/tags/saga-orchestration/>Saga Orchestration</a></li></ul><nav class=paginav><a class=prev href=https://devrx.io/posts/scalability-essentials-for-apis-in-high-traffic-services/><span class=title>¬´ Prev</span><br><span>Scalability Essentials for APIs in High-Traffic Services</span>
</a><a class=next href=https://devrx.io/posts/mastering-microservics-ensuring-data-consistency-with-the-outbox-pattern/><span class=title>Next ¬ª</span><br><span>Mastering Microservices: Ensuring Data Consistency with the Outbox Pattern</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on x" href="https://x.com/intent/tweet/?text=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern&amp;url=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f&amp;hashtags=microservice%2cdistributedsystem%2cmessaging%2csaga%2cEDA%2cChoreography%2cOrchestration%2cdistributedtransaction%2csagachoreography%2csagaorchestration"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f&amp;title=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern&amp;summary=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern&amp;source=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f&title=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on whatsapp" href="https://api.whatsapp.com/send?text=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern%20-%20https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on telegram" href="https://telegram.me/share/url?text=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern&amp;url=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Handling Distributed Transactions: A Deep Dive into the Saga Pattern on ycombinator" href="https://news.ycombinator.com/submitlink?t=Handling%20Distributed%20Transactions%3a%20A%20Deep%20Dive%20into%20the%20Saga%20Pattern&u=https%3a%2f%2fdevrx.io%2fposts%2fdistributed-transaction-with-saga-pattern%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://devrx.io/>ùê∑ùëíùë£‚Ñùùë•.ùëñùëú</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>